--
-- PostgreSQL database dump
--

SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;

--
-- Name: acs; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA acs;


ALTER SCHEMA acs OWNER TO postgres;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


--
-- Name: pgcrypto; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA public;


--
-- Name: EXTENSION pgcrypto; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgcrypto IS 'cryptographic functions';


--
-- Name: uuid-ossp; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA public;


--
-- Name: EXTENSION "uuid-ossp"; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION "uuid-ossp" IS 'generate universally unique identifiers (UUIDs)';


SET search_path = public, pg_catalog;

--
-- Name: acs_auth(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION acs_auth(text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
cnt int;
token text;
BEGIN
token = '';
SELECT COUNT(*) INTO cnt FROM acs.users WHERE id=$1 AND pass=crypt($2, pass);
IF cnt > 0 THEN
	token = uuid_generate_v4();
	INSERT INTO acs.tokens(user_id, token, exp_date) VALUES ($1, token, now() + interval '1' day);
	DELETE FROM acs.tokens WHERE user_id=$1 AND exp_date < now();
ELSE
	RAISE notice 'wrong';
END IF;

RETURN token;
END;
$_$;


ALTER FUNCTION public.acs_auth(text, text) OWNER TO postgres;

--
-- Name: acs_check_user(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION acs_check_user(text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
cnt int;
BEGIN
SELECT COUNT(*) INTO cnt FROM acs.tokens WHERE user_id=$1 AND token=$2 AND exp_date >= now();
IF cnt > 0 THEN
	RETURN TRUE;
ELSE
	RETURN FALSE;
END IF;
END;
$_$;


ALTER FUNCTION public.acs_check_user(text, text) OWNER TO postgres;

--
-- Name: acs_install(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION acs_install() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
cnt int;
BEGIN

SELECT COUNT(*) INTO cnt FROM information_schema.schemata WHERE schema_name = 'acs';
IF cnt = 0 THEN
	CREATE SCHEMA acs;
END IF;

--users
CREATE TABLE IF NOT EXISTS acs.users (
	record_id SERIAL PRIMARY KEY,
	id text NOT NULL,
	pass text NOT NULL,
	position_user text,
	realname text
);
--groups
CREATE TABLE IF NOT EXISTS acs.groups (
	record_id SERIAL PRIMARY KEY,
	group_id text NOT NULL,
	realname text
);
--group-user
CREATE TABLE IF NOT EXISTS acs.group_user (
	record_id SERIAL PRIMARY KEY,
	group_id uuid NOT NULL,
	user_id text NOT NULL
);
--group-struct
CREATE TABLE IF NOT EXISTS acs.groups_struct (
	record_id SERIAL PRIMARY KEY,
	group_id uuid NOT NULL,
	parent_id uuid,
	level integer
);
--rules
CREATE TABLE IF NOT EXISTS acs.rules (
	record_id SERIAL PRIMARY KEY,
	rule_id uuid NOT NULL,
	rule_desc text
);
--rules-data
CREATE TABLE IF NOT EXISTS acs.rules_data (
	record_id SERIAL PRIMARY KEY,
	rule_id uuid NOT NULL,
	rule_user text,
	rule_action text,
	rule_group text
);
--tokens
CREATE TABLE IF NOT EXISTS acs.tokens (
	user_id text NOT NULL,
	token text NOT NULL,
	exp_date timestamp
);
--changes_history
CREATE TABLE acs.changes_history
(
  change_uuid uuid NOT NULL DEFAULT uuid_generate_v4(),
  change_date timestamp without time zone NOT NULL,
  change_type text,
  change_db text,
  hash text
);

END;
$$;


ALTER FUNCTION public.acs_install() OWNER TO postgres;

--
-- Name: acs_protect_table(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION acs_protect_table(text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
user_name text;
BEGIN

EXECUTE 'ALTER TABLE '|| $1 ||' ADD COLUMN rule uuid';
EXECUTE 'ALTER TABLE '|| $1 ||' RENAME TO ' || $1 || '_protected';
EXECUTE 'CREATE OR REPLACE VIEW  '|| $1 ||' AS SELECT * FROM ' || $1 || '_protected';

FOR user_name IN
	SELECT usename FROM pg_user
   LOOP
	EXECUTE 'GRANT ALL PRIVILEGES ON ' || $1 || ' TO ' || user_name;
	EXECUTE 'REVOKE ALL PRIVILEGES ON ' || $1 || '_protected FROM ' || user_name;
   END LOOP;

END;
$_$;


ALTER FUNCTION public.acs_protect_table(text) OWNER TO postgres;

--
-- Name: acs_vcs_init(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION acs_vcs_init() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
tname text;
BEGIN

FOR tname IN
	SELECT quote_ident(table_name)
	FROM   information_schema.tables
	WHERE  table_schema = 'public' AND table_type = 'BASE TABLE'
   LOOP
	EXECUTE 'ALTER TABLE '|| tname ||' ADD COLUMN time_modified timestamp';
	EXECUTE 'ALTER TABLE '|| tname ||' ALTER COLUMN time_modified SET default current_timestamp';
	EXECUTE 'UPDATE '|| tname ||' SET time_modified=current_timestamp';
   END LOOP;

INSERT INTO acs.changes_history(change_uuid, change_date, change_type, change_db) VALUES (uuid_generate_v4(), now(), 'init', current_database());

END;
$$;


ALTER FUNCTION public.acs_vcs_init() OWNER TO postgres;

SET search_path = acs, pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: changes_history; Type: TABLE; Schema: acs; Owner: postgres; Tablespace: 
--

CREATE TABLE changes_history (
    change_uuid uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    change_date timestamp without time zone NOT NULL,
    change_type text,
    change_db text,
    hash text
);


ALTER TABLE acs.changes_history OWNER TO postgres;

--
-- Name: group_user; Type: TABLE; Schema: acs; Owner: postgres; Tablespace: 
--

CREATE TABLE group_user (
    record_id integer NOT NULL,
    group_id uuid NOT NULL,
    user_id text NOT NULL
);


ALTER TABLE acs.group_user OWNER TO postgres;

--
-- Name: group_user_record_id_seq; Type: SEQUENCE; Schema: acs; Owner: postgres
--

CREATE SEQUENCE group_user_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acs.group_user_record_id_seq OWNER TO postgres;

--
-- Name: group_user_record_id_seq; Type: SEQUENCE OWNED BY; Schema: acs; Owner: postgres
--

ALTER SEQUENCE group_user_record_id_seq OWNED BY group_user.record_id;


--
-- Name: groups; Type: TABLE; Schema: acs; Owner: postgres; Tablespace: 
--

CREATE TABLE groups (
    record_id integer NOT NULL,
    group_id text NOT NULL,
    realname text
);


ALTER TABLE acs.groups OWNER TO postgres;

--
-- Name: groups_record_id_seq; Type: SEQUENCE; Schema: acs; Owner: postgres
--

CREATE SEQUENCE groups_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acs.groups_record_id_seq OWNER TO postgres;

--
-- Name: groups_record_id_seq; Type: SEQUENCE OWNED BY; Schema: acs; Owner: postgres
--

ALTER SEQUENCE groups_record_id_seq OWNED BY groups.record_id;


--
-- Name: groups_struct; Type: TABLE; Schema: acs; Owner: postgres; Tablespace: 
--

CREATE TABLE groups_struct (
    record_id integer NOT NULL,
    group_id uuid NOT NULL,
    parent_id uuid,
    level integer
);


ALTER TABLE acs.groups_struct OWNER TO postgres;

--
-- Name: groups_struct_record_id_seq; Type: SEQUENCE; Schema: acs; Owner: postgres
--

CREATE SEQUENCE groups_struct_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acs.groups_struct_record_id_seq OWNER TO postgres;

--
-- Name: groups_struct_record_id_seq; Type: SEQUENCE OWNED BY; Schema: acs; Owner: postgres
--

ALTER SEQUENCE groups_struct_record_id_seq OWNED BY groups_struct.record_id;


--
-- Name: rules; Type: TABLE; Schema: acs; Owner: postgres; Tablespace: 
--

CREATE TABLE rules (
    record_id integer NOT NULL,
    rule_id uuid NOT NULL,
    rule_desc text
);


ALTER TABLE acs.rules OWNER TO postgres;

--
-- Name: rules_data; Type: TABLE; Schema: acs; Owner: postgres; Tablespace: 
--

CREATE TABLE rules_data (
    record_id integer NOT NULL,
    rule_id uuid NOT NULL,
    rule_user text,
    rule_action text,
    rule_group text
);


ALTER TABLE acs.rules_data OWNER TO postgres;

--
-- Name: rules_data_record_id_seq; Type: SEQUENCE; Schema: acs; Owner: postgres
--

CREATE SEQUENCE rules_data_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acs.rules_data_record_id_seq OWNER TO postgres;

--
-- Name: rules_data_record_id_seq; Type: SEQUENCE OWNED BY; Schema: acs; Owner: postgres
--

ALTER SEQUENCE rules_data_record_id_seq OWNED BY rules_data.record_id;


--
-- Name: rules_record_id_seq; Type: SEQUENCE; Schema: acs; Owner: postgres
--

CREATE SEQUENCE rules_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acs.rules_record_id_seq OWNER TO postgres;

--
-- Name: rules_record_id_seq; Type: SEQUENCE OWNED BY; Schema: acs; Owner: postgres
--

ALTER SEQUENCE rules_record_id_seq OWNED BY rules.record_id;


--
-- Name: tokens; Type: TABLE; Schema: acs; Owner: postgres; Tablespace: 
--

CREATE TABLE tokens (
    user_id text NOT NULL,
    token text NOT NULL,
    exp_date timestamp without time zone
);


ALTER TABLE acs.tokens OWNER TO postgres;

--
-- Name: users; Type: TABLE; Schema: acs; Owner: postgres; Tablespace: 
--

CREATE TABLE users (
    record_id integer NOT NULL,
    id text NOT NULL,
    pass text NOT NULL,
    position_user text,
    realname text
);


ALTER TABLE acs.users OWNER TO postgres;

--
-- Name: users_record_id_seq; Type: SEQUENCE; Schema: acs; Owner: postgres
--

CREATE SEQUENCE users_record_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acs.users_record_id_seq OWNER TO postgres;

--
-- Name: users_record_id_seq; Type: SEQUENCE OWNED BY; Schema: acs; Owner: postgres
--

ALTER SEQUENCE users_record_id_seq OWNED BY users.record_id;


SET search_path = public, pg_catalog;

--
-- Name: fruits; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE fruits (
    name name,
    cnt integer,
    time_modified timestamp without time zone DEFAULT now()
);


ALTER TABLE public.fruits OWNER TO postgres;

--
-- Name: test_protected; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE test_protected (
    id text,
    name_p text,
    property text,
    price double precision,
    rule uuid,
    time_modified timestamp without time zone DEFAULT now()
);


ALTER TABLE public.test_protected OWNER TO postgres;

--
-- Name: test; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW test AS
 SELECT test_protected.id,
    test_protected.name_p,
    test_protected.property,
    test_protected.price,
    test_protected.rule
   FROM test_protected;


ALTER TABLE public.test OWNER TO postgres;

--
-- Name: ttt; Type: TABLE; Schema: public; Owner: postgres; Tablespace: 
--

CREATE TABLE ttt (
    val integer,
    time_modified timestamp without time zone DEFAULT now()
);


ALTER TABLE public.ttt OWNER TO postgres;

SET search_path = acs, pg_catalog;

--
-- Name: record_id; Type: DEFAULT; Schema: acs; Owner: postgres
--

ALTER TABLE ONLY group_user ALTER COLUMN record_id SET DEFAULT nextval('group_user_record_id_seq'::regclass);


--
-- Name: record_id; Type: DEFAULT; Schema: acs; Owner: postgres
--

ALTER TABLE ONLY groups ALTER COLUMN record_id SET DEFAULT nextval('groups_record_id_seq'::regclass);


--
-- Name: record_id; Type: DEFAULT; Schema: acs; Owner: postgres
--

ALTER TABLE ONLY groups_struct ALTER COLUMN record_id SET DEFAULT nextval('groups_struct_record_id_seq'::regclass);


--
-- Name: record_id; Type: DEFAULT; Schema: acs; Owner: postgres
--

ALTER TABLE ONLY rules ALTER COLUMN record_id SET DEFAULT nextval('rules_record_id_seq'::regclass);


--
-- Name: record_id; Type: DEFAULT; Schema: acs; Owner: postgres
--

ALTER TABLE ONLY rules_data ALTER COLUMN record_id SET DEFAULT nextval('rules_data_record_id_seq'::regclass);


--
-- Name: record_id; Type: DEFAULT; Schema: acs; Owner: postgres
--

ALTER TABLE ONLY users ALTER COLUMN record_id SET DEFAULT nextval('users_record_id_seq'::regclass);


--
-- Data for Name: changes_history; Type: TABLE DATA; Schema: acs; Owner: postgres
--

COPY changes_history (change_uuid, change_date, change_type, change_db, hash) FROM stdin;
\.


--
-- Data for Name: group_user; Type: TABLE DATA; Schema: acs; Owner: postgres
--

COPY group_user (record_id, group_id, user_id) FROM stdin;
\.


--
-- Name: group_user_record_id_seq; Type: SEQUENCE SET; Schema: acs; Owner: postgres
--

SELECT pg_catalog.setval('group_user_record_id_seq', 1, false);


--
-- Data for Name: groups; Type: TABLE DATA; Schema: acs; Owner: postgres
--

COPY groups (record_id, group_id, realname) FROM stdin;
1	e9a2d9a6-5c1d-4f74-7fa5-79973c7031a2	Группа_1
\.


--
-- Name: groups_record_id_seq; Type: SEQUENCE SET; Schema: acs; Owner: postgres
--

SELECT pg_catalog.setval('groups_record_id_seq', 1, true);


--
-- Data for Name: groups_struct; Type: TABLE DATA; Schema: acs; Owner: postgres
--

COPY groups_struct (record_id, group_id, parent_id, level) FROM stdin;
\.


--
-- Name: groups_struct_record_id_seq; Type: SEQUENCE SET; Schema: acs; Owner: postgres
--

SELECT pg_catalog.setval('groups_struct_record_id_seq', 1, false);


--
-- Data for Name: rules; Type: TABLE DATA; Schema: acs; Owner: postgres
--

COPY rules (record_id, rule_id, rule_desc) FROM stdin;
\.


--
-- Data for Name: rules_data; Type: TABLE DATA; Schema: acs; Owner: postgres
--

COPY rules_data (record_id, rule_id, rule_user, rule_action, rule_group) FROM stdin;
\.


--
-- Name: rules_data_record_id_seq; Type: SEQUENCE SET; Schema: acs; Owner: postgres
--

SELECT pg_catalog.setval('rules_data_record_id_seq', 1, false);


--
-- Name: rules_record_id_seq; Type: SEQUENCE SET; Schema: acs; Owner: postgres
--

SELECT pg_catalog.setval('rules_record_id_seq', 1, false);


--
-- Data for Name: tokens; Type: TABLE DATA; Schema: acs; Owner: postgres
--

COPY tokens (user_id, token, exp_date) FROM stdin;
admin	58fac413-f605-4d00-8718-bcb495d03bc6	2016-03-17 18:00:10.238606
admin	0ef148ab-9c69-484f-ac70-5afd837d9056	2016-03-17 18:10:33.629031
\.


--
-- Data for Name: users; Type: TABLE DATA; Schema: acs; Owner: postgres
--

COPY users (record_id, id, pass, position_user, realname) FROM stdin;
2	admin	$2a$06$sb75/0haA0a3456UZBJRQecCUJjM68j6AANn6.oPeubhKpjxcfHKG		Администратор
\.


--
-- Name: users_record_id_seq; Type: SEQUENCE SET; Schema: acs; Owner: postgres
--

SELECT pg_catalog.setval('users_record_id_seq', 2, true);


SET search_path = public, pg_catalog;

--
-- Data for Name: fruits; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY fruits (name, cnt, time_modified) FROM stdin;
name1	2	2016-03-16 17:06:43.452493
name2	2	2016-03-16 17:06:43.452493
name3	2	2016-03-16 17:06:43.452493
name3	6	2016-03-16 17:06:43.452493
\.


--
-- Data for Name: test_protected; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY test_protected (id, name_p, property, price, rule, time_modified) FROM stdin;
1	name1	s	120	\N	2016-03-16 17:06:43.452493
5	name5	v	124	\N	2016-03-16 17:06:43.452493
2	name2	s	150	\N	2016-03-16 17:06:43.452493
4	name4	z	120	\N	2016-03-16 17:06:43.452493
3	name3	q	150	937dd1f3-70ea-479e-7b87-4afd1b380f06	2016-03-16 17:06:43.452493
\.


--
-- Data for Name: ttt; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY ttt (val, time_modified) FROM stdin;
100	2016-03-16 17:06:43.452493
10	2016-03-16 17:06:43.452493
\.


SET search_path = acs, pg_catalog;

--
-- Name: group_user_pkey; Type: CONSTRAINT; Schema: acs; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY group_user
    ADD CONSTRAINT group_user_pkey PRIMARY KEY (record_id);


--
-- Name: groups_pkey; Type: CONSTRAINT; Schema: acs; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY groups
    ADD CONSTRAINT groups_pkey PRIMARY KEY (record_id);


--
-- Name: groups_struct_pkey; Type: CONSTRAINT; Schema: acs; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY groups_struct
    ADD CONSTRAINT groups_struct_pkey PRIMARY KEY (record_id);


--
-- Name: rules_data_pkey; Type: CONSTRAINT; Schema: acs; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rules_data
    ADD CONSTRAINT rules_data_pkey PRIMARY KEY (record_id);


--
-- Name: rules_pkey; Type: CONSTRAINT; Schema: acs; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY rules
    ADD CONSTRAINT rules_pkey PRIMARY KEY (record_id);


--
-- Name: users_pkey; Type: CONSTRAINT; Schema: acs; Owner: postgres; Tablespace: 
--

ALTER TABLE ONLY users
    ADD CONSTRAINT users_pkey PRIMARY KEY (record_id);


--
-- Name: public; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM postgres;
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO PUBLIC;


SET search_path = public, pg_catalog;

--
-- Name: test_protected; Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON TABLE test_protected FROM PUBLIC;
REVOKE ALL ON TABLE test_protected FROM postgres;


--
-- Name: test; Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON TABLE test FROM PUBLIC;
REVOKE ALL ON TABLE test FROM postgres;
GRANT ALL ON TABLE test TO postgres;
GRANT ALL ON TABLE test TO admin;
GRANT ALL ON TABLE test TO dima;


--
-- PostgreSQL database dump complete
--

